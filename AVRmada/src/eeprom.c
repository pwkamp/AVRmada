/* ---------------------------------------------------------------------------
 * eeprom.c - Implementation for EEPROM Image reading/writing
 *
 * v2.0
 * Copyright (c) 2025 Peter Kamp and Brendan Brooks
 * --------------------------------------------------------------------------- */
#include "eeprom.h"
#include "gfx.h"
#include <avr/io.h>
#include <avr/pgmspace.h>

#ifdef CLEAR_EEPROM
// Wipe IMG_BYTES bytes to 0x00
static void clearEepromImage(void) {
	for (uint16_t i = 0; i < IMG_BYTES; i++) {
		eeprom_write_byte((uint8_t*)(EEPROM_IMAGE_ADDR + i), 0x00);
	}
}
#else
static inline void clearEepromImage(void) { }
#endif

#ifdef FLASH_IMAGE
// Flash resident copy of image
const uint8_t PROGMEM imageData[IMG_BYTES] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xA9, 0x9A,
	0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x92, 0x66, 0x66, 0x62, 0xD7,
	0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x89, 0x65, 0x54, 0x55, 0x56, 0x66, 0x22, 0x9A,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x82, 0x55, 0x44, 0x44, 0x45, 0x55, 0x66, 0x22, 0x7A, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA2, 0x54, 0x44, 0x44, 0x45, 0x45, 0x56, 0x62, 0x22, 0x78, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x54,
	0x44, 0x44, 0x44, 0x44, 0x55, 0x56, 0x62, 0x22, 0x98, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x54, 0x44, 0x43,
	0x33, 0x34, 0x44, 0x55, 0x56, 0x22, 0x27, 0x88, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xD4, 0x44, 0x33, 0x33, 0x34,
	0x34, 0x44, 0x55, 0x62, 0x22, 0x29, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x44, 0x33, 0x33, 0x33, 0x33, 0x43,
	0x45, 0x56, 0x62, 0x22, 0x98, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0A, 0x64, 0x43, 0x33, 0x33, 0x33, 0x33, 0x44, 0x45,
	0x56, 0x22, 0x79, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x95, 0x43, 0x33, 0x33, 0x33, 0x33, 0x34, 0x44, 0x55, 0x62,
	0x22, 0x99, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x09, 0x54, 0x33, 0x33, 0x33, 0x33, 0x33, 0x44, 0x55, 0x55, 0x22, 0x77,
	0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94,
	0x43, 0x33, 0x33, 0x33, 0x33, 0x34, 0x45, 0x45, 0x62, 0xD7, 0x79, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x44, 0x54,
	0x34, 0x33, 0x33, 0x33, 0x55, 0x55, 0x66, 0x22, 0x29, 0x88, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x65, 0x56, 0x66,
	0x33, 0x34, 0x52, 0x22, 0x22, 0x7D, 0x2D, 0x99, 0x88, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x45, 0x33, 0x35, 0x54, 0x35,
	0x52, 0x66, 0x55, 0x6D, 0x72, 0x29, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x09, 0xD6, 0x46, 0x67, 0x26, 0x54, 0x52, 0x26,
	0x62, 0x2D, 0xD7, 0x77, 0x98, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xD5, 0x64, 0x26, 0xD2, 0x65, 0x44, 0x22, 0x25, 0x79,
	0x79, 0x97, 0x79, 0x92, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x44, 0x34, 0x44, 0x65, 0x43, 0x52, 0x76, 0x55, 0x62, 0x72,
	0x62, 0x77, 0x29, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x13, 0x33, 0x33, 0x43, 0x44, 0x36, 0x22, 0x25, 0x56, 0x66, 0x62, 0x2D,
	0x72, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x34,
	0x33, 0x33, 0x33, 0x43, 0x52, 0x26, 0x55, 0x45, 0x66, 0x22, 0x79, 0x27,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x33, 0x33,
	0x33, 0x33, 0x35, 0x22, 0x25, 0x54, 0x56, 0x22, 0xD2, 0x72, 0x90, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x33, 0x33, 0x35,
	0x65, 0x79, 0x22, 0x65, 0x55, 0x62, 0x27, 0x22, 0x28, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x33, 0x33, 0x33, 0x45, 0x52,
	0x92, 0x25, 0x55, 0x52, 0x2D, 0x27, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x33, 0x33, 0x45, 0x66, 0x62, 0x22,
	0x65, 0x52, 0x22, 0x72, 0xD2, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x43, 0x44, 0x56, 0x22, 0x22, 0x22, 0x72, 0x22,
	0x22, 0x72, 0x72, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x44, 0x22, 0x65, 0x55, 0x62, 0x27, 0x99, 0x22, 0x72,
	0x72, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x73, 0x46, 0x65, 0x56, 0x66, 0x22, 0x72, 0x22, 0x77, 0x27, 0xD7,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
	0x44, 0x64, 0x34, 0x45, 0x56, 0x22, 0x22, 0x72, 0x72, 0x72, 0x90, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x32,
	0x54, 0x45, 0x66, 0x22, 0x22, 0x97, 0x77, 0x7D, 0xD7, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x66, 0x44,
	0x45, 0x55, 0x52, 0x99, 0x77, 0x77, 0xD7, 0xE8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0xD6, 0x54, 0x44,
	0x52, 0x29, 0x99, 0x77, 0x77, 0xDE, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xDD, 0xD6, 0x65, 0x52, 0x29,
	0x88, 0x99, 0x77, 0x7E, 0xC1, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x69, 0xDD, 0x22, 0x79, 0x88, 0x99,
	0x77, 0x26, 0xEC, 0xE8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE4, 0xDD, 0x99, 0x99, 0x89, 0x99, 0x79, 0x2E,
	0xEC, 0xEA, 0x8A, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0E, 0xB5, 0x46, 0xDD, 0xD7, 0x77, 0x72, 0x6E, 0xCE, 0xC1,
	0x8A, 0x8A, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x88, 0xEB, 0xC5, 0x44, 0x46, 0x62, 0x25, 0xCC, 0xCC, 0xC1, 0xAA, 0xA1,
	0xAA, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xA1, 0x1E,
	0xBB, 0x44, 0x44, 0x44, 0x3B, 0xBC, 0xCC, 0xCE, 0xA1, 0xAA, 0x1A, 0x11,
	0xAA, 0x88, 0x00, 0x00, 0x00, 0x00, 0x08, 0xA1, 0x11, 0x11, 0xCB, 0xBB,
	0x44, 0x4C, 0xBB, 0xBB, 0xBC, 0xCC, 0xA1, 0x11, 0x11, 0x11, 0x1A, 0x11,
	0xAA, 0x80, 0x00, 0x08, 0xA1, 0x11, 0x11, 0x11, 0x1C, 0xBB, 0xCC, 0xCC,
	0xBB, 0xBB, 0xBC, 0xCB, 0x11, 0x11, 0x1A, 0x11, 0x11, 0xA1, 0x11, 0xA1,
	0x08, 0xA1, 0x11, 0x11, 0x11, 0x11, 0x11, 0xBC, 0xA1, 0xEE, 0xCB, 0xBB,
	0xBB, 0xCB, 0xE1, 0x11, 0x11, 0x11, 0x11, 0x1A, 0x11, 0x11, 0xA1, 0x11,
	0x11, 0x11, 0x11, 0x11, 0x11, 0x1C, 0xE1, 0xFF, 0xF1, 0x1C, 0xBB, 0xBB,
	0xC1, 0x11, 0x11, 0x11, 0xA1, 0x11, 0x1A, 0x11, 0x11, 0x11, 0x11, 0x11,
	0x11, 0x11, 0x11, 0x11, 0xEC, 0xEF, 0xFF, 0xFF, 0xEB, 0xBB, 0xCE, 0xA1,
	0x11, 0x11, 0x11, 0x11, 0x8A, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
	0x11, 0x11, 0x1C, 0xBE, 0xFF, 0xF1, 0xEB, 0xBB, 0xBE, 0x11, 0x11, 0x11,
	0x11, 0x88, 0xA1, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
	0x1E, 0xBB, 0xEF, 0xFF, 0xFC, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0x1A,
	0x11, 0x11, 0x11, 0x11, 0x10
};

_Static_assert(sizeof(imageData) == IMG_BYTES, "Bad image size");

// Copy PROGMEM to EEPROM_IMAGE_ADDR
static void writeFlashToEeprom(void) {
	for (uint16_t i = 0; i < IMG_BYTES; i++) {
		uint8_t b = pgm_read_byte(&imageData[i]);
		eeprom_update_byte((uint8_t*)(EEPROM_IMAGE_ADDR + i), b);
	}
}
#else
static inline void writeFlashToEeprom(void) { }
#endif

static const uint8_t palette[16][3] = {
	{  0,   0,   0},
	{ 63,  57,  54},
	{154, 101,  65},
	{240, 175, 139},
	{223, 159, 119},
	{205, 140, 102},
	{180, 122,  84},
	{112,  76,  48},
	{ 28,  20,  13},
	{ 88,  59,  34},
	{ 49,  39,  30},
	{240, 236, 239},
	{200, 191, 195},
	{129,  93,  62},
	{153, 139, 152},
	{110,  23, 139}
};

void initEepromImage(void) {
	clearEepromImage();
	writeFlashToEeprom();
}

void displayImage(int16_t dstX, int16_t dstY, uint8_t scale) {
	uint32_t pix = 0;
	const uint32_t total = (uint32_t)IMG_WIDTH * IMG_HEIGHT;
	const uint32_t bys = (total + 1) >> 1;

	// Ensure that the EEPROM address doesn't overflow
	if (EEPROM_IMAGE_ADDR + bys > 1024) {
		// Handle error if the image size exceeds EEPROM size
		return;
	}

	for (uint32_t b = 0; b < bys; b++) {
		uint8_t packed = eeprom_read_byte((uint8_t*)(EEPROM_IMAGE_ADDR + b));

		// high nibble, then low nibble
		for (int nib = 1; nib >= 0; nib--) {
			if (pix >= total) return;

			uint8_t idx = nib ? (packed >> 4) : (packed & 0x0F);
			if (idx >= 16) {
				// If index exceeds palette size, handle error (e.g., return or clamp)
				return;
			}

			uint16_t col = pix % IMG_WIDTH;
			uint16_t row = pix / IMG_WIDTH;

			// Ensure that the display area is within bounds
			if (dstX + col * scale >= 320 || dstY + row * scale >= 240) {
				// Handle the out-of-bounds error
				return;
			}

			uint16_t c16 = rgb(
			palette[idx][0],
			palette[idx][1],
			palette[idx][2]
			);

			fillRect(
			dstX + col * scale,
			dstY + row * scale,
			scale, scale,
			c16
			);

			pix++;
		}
	}
}

